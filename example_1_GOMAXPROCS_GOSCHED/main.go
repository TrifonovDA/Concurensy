package main

import (
	"fmt"
	"runtime"
)

func main() {
	runtime.GOMAXPROCS(1) // - количество работающих процессоров (default - 1?)

	for x := 0; x < 10; x++ {
		go func() {
			fmt.Printf("goroutine %v \n", x)
		}()
		//time.Sleep(time.Second * 1)
		runtime.Gosched() // - передача управления другой горутине?  НЕПОНЯТНО КАКОЙ (без слипа в горутине мейна не работает)
	}
	//time.Sleep(time.Second * 1)
}

/*
1. Без слипа в мейне и гошеда на одном процессоре:
горутина мейн отрабатывает быстрее создания и отработки горутин цикла, поэтому выходит nil, так как после отработки мейновой горутины, остальные убиваются

2. Со слипом в мейне, но без гошеда на одном процессоре:
горутина мейн ждет time.Sleep(time.Second * 1) горутины цикла успевают создаться, но успевают захватить только значения 10. Более того, начинается захват значений начиная с 3768 итерации...

3. Со слипом в мейне, но без гошеда на 4 процессорах:
Одна горутина успела захватить значение 5, остальные 10

4. Со слипом в цикле - естественно все горутины цикла успели создаться и отработать.

5. С гошедом без слипа в мейне на 4 процессорах происходит передача управления случайной горутине, на выходе значений почему то 0 или 0,1 (На одном процессоре работает)

6. С гошедом и слипом в мейне все работает!! (но если слип недостаточный (проверял на 10к итераций) тоже теряются значения, как в п.5)

*/
